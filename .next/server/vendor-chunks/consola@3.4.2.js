"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/consola@3.4.2";
exports.ids = ["vendor-chunks/consola@3.4.2"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/consola@3.4.2/node_modules/consola/dist/core.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/consola@3.4.2/node_modules/consola/dist/core.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Consola: () => (/* binding */ Consola),\n/* harmony export */   LogLevels: () => (/* binding */ LogLevels),\n/* harmony export */   LogTypes: () => (/* binding */ LogTypes),\n/* harmony export */   createConsola: () => (/* binding */ createConsola)\n/* harmony export */ });\nconst LogLevels = {\n  silent: Number.NEGATIVE_INFINITY,\n  fatal: 0,\n  error: 0,\n  warn: 1,\n  log: 2,\n  info: 3,\n  success: 3,\n  fail: 3,\n  ready: 3,\n  start: 3,\n  box: 3,\n  debug: 4,\n  trace: 5,\n  verbose: Number.POSITIVE_INFINITY\n};\nconst LogTypes = {\n  // Silent\n  silent: {\n    level: -1\n  },\n  // Level 0\n  fatal: {\n    level: LogLevels.fatal\n  },\n  error: {\n    level: LogLevels.error\n  },\n  // Level 1\n  warn: {\n    level: LogLevels.warn\n  },\n  // Level 2\n  log: {\n    level: LogLevels.log\n  },\n  // Level 3\n  info: {\n    level: LogLevels.info\n  },\n  success: {\n    level: LogLevels.success\n  },\n  fail: {\n    level: LogLevels.fail\n  },\n  ready: {\n    level: LogLevels.info\n  },\n  start: {\n    level: LogLevels.info\n  },\n  box: {\n    level: LogLevels.info\n  },\n  // Level 4\n  debug: {\n    level: LogLevels.debug\n  },\n  // Level 5\n  trace: {\n    level: LogLevels.trace\n  },\n  // Verbose\n  verbose: {\n    level: LogLevels.verbose\n  }\n};\n\nfunction isPlainObject$1(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\n\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isPlainObject$1(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject$1(value) && isPlainObject$1(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Object]\";\n}\nfunction isLogObj(arg) {\n  if (!isPlainObject(arg)) {\n    return false;\n  }\n  if (!arg.message && !arg.args) {\n    return false;\n  }\n  if (arg.stack) {\n    return false;\n  }\n  return true;\n}\n\nlet paused = false;\nconst queue = [];\nclass Consola {\n  options;\n  _lastLog;\n  _mockFn;\n  /**\n   * Creates an instance of Consola with specified options or defaults.\n   *\n   * @param {Partial<ConsolaOptions>} [options={}] - Configuration options for the Consola instance.\n   */\n  constructor(options = {}) {\n    const types = options.types || LogTypes;\n    this.options = defu(\n      {\n        ...options,\n        defaults: { ...options.defaults },\n        level: _normalizeLogLevel(options.level, types),\n        reporters: [...options.reporters || []]\n      },\n      {\n        types: LogTypes,\n        throttle: 1e3,\n        throttleMin: 5,\n        formatOptions: {\n          date: true,\n          colors: false,\n          compact: true\n        }\n      }\n    );\n    for (const type in types) {\n      const defaults = {\n        type,\n        ...this.options.defaults,\n        ...types[type]\n      };\n      this[type] = this._wrapLogFn(defaults);\n      this[type].raw = this._wrapLogFn(\n        defaults,\n        true\n      );\n    }\n    if (this.options.mockFn) {\n      this.mockTypes();\n    }\n    this._lastLog = {};\n  }\n  /**\n   * Gets the current log level of the Consola instance.\n   *\n   * @returns {number} The current log level.\n   */\n  get level() {\n    return this.options.level;\n  }\n  /**\n   * Sets the minimum log level that will be output by the instance.\n   *\n   * @param {number} level - The new log level to set.\n   */\n  set level(level) {\n    this.options.level = _normalizeLogLevel(\n      level,\n      this.options.types,\n      this.options.level\n    );\n  }\n  /**\n   * Displays a prompt to the user and returns the response.\n   * Throw an error if `prompt` is not supported by the current configuration.\n   *\n   * @template T\n   * @param {string} message - The message to display in the prompt.\n   * @param {T} [opts] - Optional options for the prompt. See {@link PromptOptions}.\n   * @returns {promise<T>} A promise that infer with the prompt options. See {@link PromptOptions}.\n   */\n  prompt(message, opts) {\n    if (!this.options.prompt) {\n      throw new Error(\"prompt is not supported!\");\n    }\n    return this.options.prompt(message, opts);\n  }\n  /**\n   * Creates a new instance of Consola, inheriting options from the current instance, with possible overrides.\n   *\n   * @param {Partial<ConsolaOptions>} options - Optional overrides for the new instance. See {@link ConsolaOptions}.\n   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.\n   */\n  create(options) {\n    const instance = new Consola({\n      ...this.options,\n      ...options\n    });\n    if (this._mockFn) {\n      instance.mockTypes(this._mockFn);\n    }\n    return instance;\n  }\n  /**\n   * Creates a new Consola instance with the specified default log object properties.\n   *\n   * @param {InputLogObject} defaults - Default properties to include in any log from the new instance. See {@link InputLogObject}.\n   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.\n   */\n  withDefaults(defaults) {\n    return this.create({\n      ...this.options,\n      defaults: {\n        ...this.options.defaults,\n        ...defaults\n      }\n    });\n  }\n  /**\n   * Creates a new Consola instance with a specified tag, which will be included in every log.\n   *\n   * @param {string} tag - The tag to include in each log of the new instance.\n   * @returns {ConsolaInstance} A new Consola instance. See {@link ConsolaInstance}.\n   */\n  withTag(tag) {\n    return this.withDefaults({\n      tag: this.options.defaults.tag ? this.options.defaults.tag + \":\" + tag : tag\n    });\n  }\n  /**\n   * Adds a custom reporter to the Consola instance.\n   * Reporters will be called for each log message, depending on their implementation and log level.\n   *\n   * @param {ConsolaReporter} reporter - The reporter to add. See {@link ConsolaReporter}.\n   * @returns {Consola} The current Consola instance.\n   */\n  addReporter(reporter) {\n    this.options.reporters.push(reporter);\n    return this;\n  }\n  /**\n   * Removes a custom reporter from the Consola instance.\n   * If no reporter is specified, all reporters will be removed.\n   *\n   * @param {ConsolaReporter} reporter - The reporter to remove. See {@link ConsolaReporter}.\n   * @returns {Consola} The current Consola instance.\n   */\n  removeReporter(reporter) {\n    if (reporter) {\n      const i = this.options.reporters.indexOf(reporter);\n      if (i !== -1) {\n        return this.options.reporters.splice(i, 1);\n      }\n    } else {\n      this.options.reporters.splice(0);\n    }\n    return this;\n  }\n  /**\n   * Replaces all reporters of the Consola instance with the specified array of reporters.\n   *\n   * @param {ConsolaReporter[]} reporters - The new reporters to set. See {@link ConsolaReporter}.\n   * @returns {Consola} The current Consola instance.\n   */\n  setReporters(reporters) {\n    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];\n    return this;\n  }\n  wrapAll() {\n    this.wrapConsole();\n    this.wrapStd();\n  }\n  restoreAll() {\n    this.restoreConsole();\n    this.restoreStd();\n  }\n  /**\n   * Overrides console methods with Consola logging methods for consistent logging.\n   */\n  wrapConsole() {\n    for (const type in this.options.types) {\n      if (!console[\"__\" + type]) {\n        console[\"__\" + type] = console[type];\n      }\n      console[type] = this[type].raw;\n    }\n  }\n  /**\n   * Restores the original console methods, removing Consola overrides.\n   */\n  restoreConsole() {\n    for (const type in this.options.types) {\n      if (console[\"__\" + type]) {\n        console[type] = console[\"__\" + type];\n        delete console[\"__\" + type];\n      }\n    }\n  }\n  /**\n   * Overrides standard output and error streams to redirect them through Consola.\n   */\n  wrapStd() {\n    this._wrapStream(this.options.stdout, \"log\");\n    this._wrapStream(this.options.stderr, \"log\");\n  }\n  _wrapStream(stream, type) {\n    if (!stream) {\n      return;\n    }\n    if (!stream.__write) {\n      stream.__write = stream.write;\n    }\n    stream.write = (data) => {\n      this[type].raw(String(data).trim());\n    };\n  }\n  /**\n   * Restores the original standard output and error streams, removing the Consola redirection.\n   */\n  restoreStd() {\n    this._restoreStream(this.options.stdout);\n    this._restoreStream(this.options.stderr);\n  }\n  _restoreStream(stream) {\n    if (!stream) {\n      return;\n    }\n    if (stream.__write) {\n      stream.write = stream.__write;\n      delete stream.__write;\n    }\n  }\n  /**\n   * Pauses logging, queues incoming logs until resumed.\n   */\n  pauseLogs() {\n    paused = true;\n  }\n  /**\n   * Resumes logging, processing any queued logs.\n   */\n  resumeLogs() {\n    paused = false;\n    const _queue = queue.splice(0);\n    for (const item of _queue) {\n      item[0]._logFn(item[1], item[2]);\n    }\n  }\n  /**\n   * Replaces logging methods with mocks if a mock function is provided.\n   *\n   * @param {ConsolaOptions[\"mockFn\"]} mockFn - The function to use for mocking logging methods. See {@link ConsolaOptions[\"mockFn\"]}.\n   */\n  mockTypes(mockFn) {\n    const _mockFn = mockFn || this.options.mockFn;\n    this._mockFn = _mockFn;\n    if (typeof _mockFn !== \"function\") {\n      return;\n    }\n    for (const type in this.options.types) {\n      this[type] = _mockFn(type, this.options.types[type]) || this[type];\n      this[type].raw = this[type];\n    }\n  }\n  _wrapLogFn(defaults, isRaw) {\n    return (...args) => {\n      if (paused) {\n        queue.push([this, defaults, args, isRaw]);\n        return;\n      }\n      return this._logFn(defaults, args, isRaw);\n    };\n  }\n  _logFn(defaults, args, isRaw) {\n    if ((defaults.level || 0) > this.level) {\n      return false;\n    }\n    const logObj = {\n      date: /* @__PURE__ */ new Date(),\n      args: [],\n      ...defaults,\n      level: _normalizeLogLevel(defaults.level, this.options.types)\n    };\n    if (!isRaw && args.length === 1 && isLogObj(args[0])) {\n      Object.assign(logObj, args[0]);\n    } else {\n      logObj.args = [...args];\n    }\n    if (logObj.message) {\n      logObj.args.unshift(logObj.message);\n      delete logObj.message;\n    }\n    if (logObj.additional) {\n      if (!Array.isArray(logObj.additional)) {\n        logObj.additional = logObj.additional.split(\"\\n\");\n      }\n      logObj.args.push(\"\\n\" + logObj.additional.join(\"\\n\"));\n      delete logObj.additional;\n    }\n    logObj.type = typeof logObj.type === \"string\" ? logObj.type.toLowerCase() : \"log\";\n    logObj.tag = typeof logObj.tag === \"string\" ? logObj.tag : \"\";\n    const resolveLog = (newLog = false) => {\n      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;\n      if (this._lastLog.object && repeated > 0) {\n        const args2 = [...this._lastLog.object.args];\n        if (repeated > 1) {\n          args2.push(`(repeated ${repeated} times)`);\n        }\n        this._log({ ...this._lastLog.object, args: args2 });\n        this._lastLog.count = 1;\n      }\n      if (newLog) {\n        this._lastLog.object = logObj;\n        this._log(logObj);\n      }\n    };\n    clearTimeout(this._lastLog.timeout);\n    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;\n    this._lastLog.time = logObj.date;\n    if (diffTime < this.options.throttle) {\n      try {\n        const serializedLog = JSON.stringify([\n          logObj.type,\n          logObj.tag,\n          logObj.args\n        ]);\n        const isSameLog = this._lastLog.serialized === serializedLog;\n        this._lastLog.serialized = serializedLog;\n        if (isSameLog) {\n          this._lastLog.count = (this._lastLog.count || 0) + 1;\n          if (this._lastLog.count > this.options.throttleMin) {\n            this._lastLog.timeout = setTimeout(\n              resolveLog,\n              this.options.throttle\n            );\n            return;\n          }\n        }\n      } catch {\n      }\n    }\n    resolveLog(true);\n  }\n  _log(logObj) {\n    for (const reporter of this.options.reporters) {\n      reporter.log(logObj, {\n        options: this.options\n      });\n    }\n  }\n}\nfunction _normalizeLogLevel(input, types = {}, defaultLevel = 3) {\n  if (input === void 0) {\n    return defaultLevel;\n  }\n  if (typeof input === \"number\") {\n    return input;\n  }\n  if (types[input] && types[input].level !== void 0) {\n    return types[input].level;\n  }\n  return defaultLevel;\n}\nConsola.prototype.add = Consola.prototype.addReporter;\nConsola.prototype.remove = Consola.prototype.removeReporter;\nConsola.prototype.clear = Consola.prototype.removeReporter;\nConsola.prototype.withScope = Consola.prototype.withTag;\nConsola.prototype.mock = Consola.prototype.mockTypes;\nConsola.prototype.pause = Consola.prototype.pauseLogs;\nConsola.prototype.resume = Consola.prototype.resumeLogs;\nfunction createConsola(options = {}) {\n  return new Consola(options);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vY29uc29sYUAzLjQuMi9ub2RlX21vZHVsZXMvY29uc29sYS9kaXN0L2NvcmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZ2VzdG9yLWNvbnZpZGFkb3MvLi9ub2RlX21vZHVsZXMvLnBucG0vY29uc29sYUAzLjQuMi9ub2RlX21vZHVsZXMvY29uc29sYS9kaXN0L2NvcmUubWpzP2EwMGMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTG9nTGV2ZWxzID0ge1xuICBzaWxlbnQ6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgZmF0YWw6IDAsXG4gIGVycm9yOiAwLFxuICB3YXJuOiAxLFxuICBsb2c6IDIsXG4gIGluZm86IDMsXG4gIHN1Y2Nlc3M6IDMsXG4gIGZhaWw6IDMsXG4gIHJlYWR5OiAzLFxuICBzdGFydDogMyxcbiAgYm94OiAzLFxuICBkZWJ1ZzogNCxcbiAgdHJhY2U6IDUsXG4gIHZlcmJvc2U6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxufTtcbmNvbnN0IExvZ1R5cGVzID0ge1xuICAvLyBTaWxlbnRcbiAgc2lsZW50OiB7XG4gICAgbGV2ZWw6IC0xXG4gIH0sXG4gIC8vIExldmVsIDBcbiAgZmF0YWw6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmZhdGFsXG4gIH0sXG4gIGVycm9yOiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5lcnJvclxuICB9LFxuICAvLyBMZXZlbCAxXG4gIHdhcm46IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLndhcm5cbiAgfSxcbiAgLy8gTGV2ZWwgMlxuICBsb2c6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmxvZ1xuICB9LFxuICAvLyBMZXZlbCAzXG4gIGluZm86IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLmluZm9cbiAgfSxcbiAgc3VjY2Vzczoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMuc3VjY2Vzc1xuICB9LFxuICBmYWlsOiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5mYWlsXG4gIH0sXG4gIHJlYWR5OiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5pbmZvXG4gIH0sXG4gIHN0YXJ0OiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5pbmZvXG4gIH0sXG4gIGJveDoge1xuICAgIGxldmVsOiBMb2dMZXZlbHMuaW5mb1xuICB9LFxuICAvLyBMZXZlbCA0XG4gIGRlYnVnOiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy5kZWJ1Z1xuICB9LFxuICAvLyBMZXZlbCA1XG4gIHRyYWNlOiB7XG4gICAgbGV2ZWw6IExvZ0xldmVscy50cmFjZVxuICB9LFxuICAvLyBWZXJib3NlXG4gIHZlcmJvc2U6IHtcbiAgICBsZXZlbDogTG9nTGV2ZWxzLnZlcmJvc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCQxKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgaWYgKHByb3RvdHlwZSAhPT0gbnVsbCAmJiBwcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBNb2R1bGVdXCI7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIF9kZWZ1KGJhc2VPYmplY3QsIGRlZmF1bHRzLCBuYW1lc3BhY2UgPSBcIi5cIiwgbWVyZ2VyKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCQxKGRlZmF1bHRzKSkge1xuICAgIHJldHVybiBfZGVmdShiYXNlT2JqZWN0LCB7fSwgbmFtZXNwYWNlLCBtZXJnZXIpO1xuICB9XG4gIGNvbnN0IG9iamVjdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYmFzZU9iamVjdCkge1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIgfHwga2V5ID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGJhc2VPYmplY3Rba2V5XTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtZXJnZXIgJiYgbWVyZ2VyKG9iamVjdCwga2V5LCB2YWx1ZSwgbmFtZXNwYWNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KG9iamVjdFtrZXldKSkge1xuICAgICAgb2JqZWN0W2tleV0gPSBbLi4udmFsdWUsIC4uLm9iamVjdFtrZXldXTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QkMSh2YWx1ZSkgJiYgaXNQbGFpbk9iamVjdCQxKG9iamVjdFtrZXldKSkge1xuICAgICAgb2JqZWN0W2tleV0gPSBfZGVmdShcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9iamVjdFtrZXldLFxuICAgICAgICAobmFtZXNwYWNlID8gYCR7bmFtZXNwYWNlfS5gIDogXCJcIikgKyBrZXkudG9TdHJpbmcoKSxcbiAgICAgICAgbWVyZ2VyXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmdShtZXJnZXIpIHtcbiAgcmV0dXJuICguLi5hcmd1bWVudHNfKSA9PiAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tYXJyYXktcmVkdWNlXG4gICAgYXJndW1lbnRzXy5yZWR1Y2UoKHAsIGMpID0+IF9kZWZ1KHAsIGMsIFwiXCIsIG1lcmdlciksIHt9KVxuICApO1xufVxuY29uc3QgZGVmdSA9IGNyZWF0ZURlZnUoKTtcblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNMb2dPYmooYXJnKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChhcmcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghYXJnLm1lc3NhZ2UgJiYgIWFyZy5hcmdzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChhcmcuc3RhY2spIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmxldCBwYXVzZWQgPSBmYWxzZTtcbmNvbnN0IHF1ZXVlID0gW107XG5jbGFzcyBDb25zb2xhIHtcbiAgb3B0aW9ucztcbiAgX2xhc3RMb2c7XG4gIF9tb2NrRm47XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIENvbnNvbGEgd2l0aCBzcGVjaWZpZWQgb3B0aW9ucyBvciBkZWZhdWx0cy5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPENvbnNvbGFPcHRpb25zPn0gW29wdGlvbnM9e31dIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgQ29uc29sYSBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHR5cGVzID0gb3B0aW9ucy50eXBlcyB8fCBMb2dUeXBlcztcbiAgICB0aGlzLm9wdGlvbnMgPSBkZWZ1KFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBkZWZhdWx0czogeyAuLi5vcHRpb25zLmRlZmF1bHRzIH0sXG4gICAgICAgIGxldmVsOiBfbm9ybWFsaXplTG9nTGV2ZWwob3B0aW9ucy5sZXZlbCwgdHlwZXMpLFxuICAgICAgICByZXBvcnRlcnM6IFsuLi5vcHRpb25zLnJlcG9ydGVycyB8fCBbXV1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHR5cGVzOiBMb2dUeXBlcyxcbiAgICAgICAgdGhyb3R0bGU6IDFlMyxcbiAgICAgICAgdGhyb3R0bGVNaW46IDUsXG4gICAgICAgIGZvcm1hdE9wdGlvbnM6IHtcbiAgICAgICAgICBkYXRlOiB0cnVlLFxuICAgICAgICAgIGNvbG9yczogZmFsc2UsXG4gICAgICAgICAgY29tcGFjdDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgaW4gdHlwZXMpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICAuLi50aGlzLm9wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgIC4uLnR5cGVzW3R5cGVdXG4gICAgICB9O1xuICAgICAgdGhpc1t0eXBlXSA9IHRoaXMuX3dyYXBMb2dGbihkZWZhdWx0cyk7XG4gICAgICB0aGlzW3R5cGVdLnJhdyA9IHRoaXMuX3dyYXBMb2dGbihcbiAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgIHRydWVcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMubW9ja0ZuKSB7XG4gICAgICB0aGlzLm1vY2tUeXBlcygpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0TG9nID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgbG9nIGxldmVsIG9mIHRoZSBDb25zb2xhIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAqL1xuICBnZXQgbGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbWluaW11bSBsb2cgbGV2ZWwgdGhhdCB3aWxsIGJlIG91dHB1dCBieSB0aGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZXZlbCAtIFRoZSBuZXcgbG9nIGxldmVsIHRvIHNldC5cbiAgICovXG4gIHNldCBsZXZlbChsZXZlbCkge1xuICAgIHRoaXMub3B0aW9ucy5sZXZlbCA9IF9ub3JtYWxpemVMb2dMZXZlbChcbiAgICAgIGxldmVsLFxuICAgICAgdGhpcy5vcHRpb25zLnR5cGVzLFxuICAgICAgdGhpcy5vcHRpb25zLmxldmVsXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogRGlzcGxheXMgYSBwcm9tcHQgdG8gdGhlIHVzZXIgYW5kIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICAgKiBUaHJvdyBhbiBlcnJvciBpZiBgcHJvbXB0YCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpbiB0aGUgcHJvbXB0LlxuICAgKiBAcGFyYW0ge1R9IFtvcHRzXSAtIE9wdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBwcm9tcHQuIFNlZSB7QGxpbmsgUHJvbXB0T3B0aW9uc30uXG4gICAqIEByZXR1cm5zIHtwcm9taXNlPFQ+fSBBIHByb21pc2UgdGhhdCBpbmZlciB3aXRoIHRoZSBwcm9tcHQgb3B0aW9ucy4gU2VlIHtAbGluayBQcm9tcHRPcHRpb25zfS5cbiAgICovXG4gIHByb21wdChtZXNzYWdlLCBvcHRzKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMucHJvbXB0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9tcHQgaXMgbm90IHN1cHBvcnRlZCFcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucHJvbXB0KG1lc3NhZ2UsIG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbnNvbGEsIGluaGVyaXRpbmcgb3B0aW9ucyBmcm9tIHRoZSBjdXJyZW50IGluc3RhbmNlLCB3aXRoIHBvc3NpYmxlIG92ZXJyaWRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPENvbnNvbGFPcHRpb25zPn0gb3B0aW9ucyAtIE9wdGlvbmFsIG92ZXJyaWRlcyBmb3IgdGhlIG5ldyBpbnN0YW5jZS4gU2VlIHtAbGluayBDb25zb2xhT3B0aW9uc30uXG4gICAqIEByZXR1cm5zIHtDb25zb2xhSW5zdGFuY2V9IEEgbmV3IENvbnNvbGEgaW5zdGFuY2UuIFNlZSB7QGxpbmsgQ29uc29sYUluc3RhbmNlfS5cbiAgICovXG4gIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ29uc29sYSh7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX21vY2tGbikge1xuICAgICAgaW5zdGFuY2UubW9ja1R5cGVzKHRoaXMuX21vY2tGbik7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDb25zb2xhIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBkZWZhdWx0IGxvZyBvYmplY3QgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtJbnB1dExvZ09iamVjdH0gZGVmYXVsdHMgLSBEZWZhdWx0IHByb3BlcnRpZXMgdG8gaW5jbHVkZSBpbiBhbnkgbG9nIGZyb20gdGhlIG5ldyBpbnN0YW5jZS4gU2VlIHtAbGluayBJbnB1dExvZ09iamVjdH0uXG4gICAqIEByZXR1cm5zIHtDb25zb2xhSW5zdGFuY2V9IEEgbmV3IENvbnNvbGEgaW5zdGFuY2UuIFNlZSB7QGxpbmsgQ29uc29sYUluc3RhbmNlfS5cbiAgICovXG4gIHdpdGhEZWZhdWx0cyhkZWZhdWx0cykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAuLi50aGlzLm9wdGlvbnMuZGVmYXVsdHMsXG4gICAgICAgIC4uLmRlZmF1bHRzXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ29uc29sYSBpbnN0YW5jZSB3aXRoIGEgc3BlY2lmaWVkIHRhZywgd2hpY2ggd2lsbCBiZSBpbmNsdWRlZCBpbiBldmVyeSBsb2cuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgLSBUaGUgdGFnIHRvIGluY2x1ZGUgaW4gZWFjaCBsb2cgb2YgdGhlIG5ldyBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0NvbnNvbGFJbnN0YW5jZX0gQSBuZXcgQ29uc29sYSBpbnN0YW5jZS4gU2VlIHtAbGluayBDb25zb2xhSW5zdGFuY2V9LlxuICAgKi9cbiAgd2l0aFRhZyh0YWcpIHtcbiAgICByZXR1cm4gdGhpcy53aXRoRGVmYXVsdHMoe1xuICAgICAgdGFnOiB0aGlzLm9wdGlvbnMuZGVmYXVsdHMudGFnID8gdGhpcy5vcHRpb25zLmRlZmF1bHRzLnRhZyArIFwiOlwiICsgdGFnIDogdGFnXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjdXN0b20gcmVwb3J0ZXIgdG8gdGhlIENvbnNvbGEgaW5zdGFuY2UuXG4gICAqIFJlcG9ydGVycyB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBsb2cgbWVzc2FnZSwgZGVwZW5kaW5nIG9uIHRoZWlyIGltcGxlbWVudGF0aW9uIGFuZCBsb2cgbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7Q29uc29sYVJlcG9ydGVyfSByZXBvcnRlciAtIFRoZSByZXBvcnRlciB0byBhZGQuIFNlZSB7QGxpbmsgQ29uc29sYVJlcG9ydGVyfS5cbiAgICogQHJldHVybnMge0NvbnNvbGF9IFRoZSBjdXJyZW50IENvbnNvbGEgaW5zdGFuY2UuXG4gICAqL1xuICBhZGRSZXBvcnRlcihyZXBvcnRlcikge1xuICAgIHRoaXMub3B0aW9ucy5yZXBvcnRlcnMucHVzaChyZXBvcnRlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjdXN0b20gcmVwb3J0ZXIgZnJvbSB0aGUgQ29uc29sYSBpbnN0YW5jZS5cbiAgICogSWYgbm8gcmVwb3J0ZXIgaXMgc3BlY2lmaWVkLCBhbGwgcmVwb3J0ZXJzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtDb25zb2xhUmVwb3J0ZXJ9IHJlcG9ydGVyIC0gVGhlIHJlcG9ydGVyIHRvIHJlbW92ZS4gU2VlIHtAbGluayBDb25zb2xhUmVwb3J0ZXJ9LlxuICAgKiBAcmV0dXJucyB7Q29uc29sYX0gVGhlIGN1cnJlbnQgQ29uc29sYSBpbnN0YW5jZS5cbiAgICovXG4gIHJlbW92ZVJlcG9ydGVyKHJlcG9ydGVyKSB7XG4gICAgaWYgKHJlcG9ydGVyKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5vcHRpb25zLnJlcG9ydGVycy5pbmRleE9mKHJlcG9ydGVyKTtcbiAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJlcG9ydGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9ucy5yZXBvcnRlcnMuc3BsaWNlKDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIHJlcG9ydGVycyBvZiB0aGUgQ29uc29sYSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgYXJyYXkgb2YgcmVwb3J0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbnNvbGFSZXBvcnRlcltdfSByZXBvcnRlcnMgLSBUaGUgbmV3IHJlcG9ydGVycyB0byBzZXQuIFNlZSB7QGxpbmsgQ29uc29sYVJlcG9ydGVyfS5cbiAgICogQHJldHVybnMge0NvbnNvbGF9IFRoZSBjdXJyZW50IENvbnNvbGEgaW5zdGFuY2UuXG4gICAqL1xuICBzZXRSZXBvcnRlcnMocmVwb3J0ZXJzKSB7XG4gICAgdGhpcy5vcHRpb25zLnJlcG9ydGVycyA9IEFycmF5LmlzQXJyYXkocmVwb3J0ZXJzKSA/IHJlcG9ydGVycyA6IFtyZXBvcnRlcnNdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHdyYXBBbGwoKSB7XG4gICAgdGhpcy53cmFwQ29uc29sZSgpO1xuICAgIHRoaXMud3JhcFN0ZCgpO1xuICB9XG4gIHJlc3RvcmVBbGwoKSB7XG4gICAgdGhpcy5yZXN0b3JlQ29uc29sZSgpO1xuICAgIHRoaXMucmVzdG9yZVN0ZCgpO1xuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgY29uc29sZSBtZXRob2RzIHdpdGggQ29uc29sYSBsb2dnaW5nIG1ldGhvZHMgZm9yIGNvbnNpc3RlbnQgbG9nZ2luZy5cbiAgICovXG4gIHdyYXBDb25zb2xlKCkge1xuICAgIGZvciAoY29uc3QgdHlwZSBpbiB0aGlzLm9wdGlvbnMudHlwZXMpIHtcbiAgICAgIGlmICghY29uc29sZVtcIl9fXCIgKyB0eXBlXSkge1xuICAgICAgICBjb25zb2xlW1wiX19cIiArIHR5cGVdID0gY29uc29sZVt0eXBlXTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGVbdHlwZV0gPSB0aGlzW3R5cGVdLnJhdztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc3RvcmVzIHRoZSBvcmlnaW5hbCBjb25zb2xlIG1ldGhvZHMsIHJlbW92aW5nIENvbnNvbGEgb3ZlcnJpZGVzLlxuICAgKi9cbiAgcmVzdG9yZUNvbnNvbGUoKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRoaXMub3B0aW9ucy50eXBlcykge1xuICAgICAgaWYgKGNvbnNvbGVbXCJfX1wiICsgdHlwZV0pIHtcbiAgICAgICAgY29uc29sZVt0eXBlXSA9IGNvbnNvbGVbXCJfX1wiICsgdHlwZV07XG4gICAgICAgIGRlbGV0ZSBjb25zb2xlW1wiX19cIiArIHR5cGVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogT3ZlcnJpZGVzIHN0YW5kYXJkIG91dHB1dCBhbmQgZXJyb3Igc3RyZWFtcyB0byByZWRpcmVjdCB0aGVtIHRocm91Z2ggQ29uc29sYS5cbiAgICovXG4gIHdyYXBTdGQoKSB7XG4gICAgdGhpcy5fd3JhcFN0cmVhbSh0aGlzLm9wdGlvbnMuc3Rkb3V0LCBcImxvZ1wiKTtcbiAgICB0aGlzLl93cmFwU3RyZWFtKHRoaXMub3B0aW9ucy5zdGRlcnIsIFwibG9nXCIpO1xuICB9XG4gIF93cmFwU3RyZWFtKHN0cmVhbSwgdHlwZSkge1xuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc3RyZWFtLl9fd3JpdGUpIHtcbiAgICAgIHN0cmVhbS5fX3dyaXRlID0gc3RyZWFtLndyaXRlO1xuICAgIH1cbiAgICBzdHJlYW0ud3JpdGUgPSAoZGF0YSkgPT4ge1xuICAgICAgdGhpc1t0eXBlXS5yYXcoU3RyaW5nKGRhdGEpLnRyaW0oKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0YW5kYXJkIG91dHB1dCBhbmQgZXJyb3Igc3RyZWFtcywgcmVtb3ZpbmcgdGhlIENvbnNvbGEgcmVkaXJlY3Rpb24uXG4gICAqL1xuICByZXN0b3JlU3RkKCkge1xuICAgIHRoaXMuX3Jlc3RvcmVTdHJlYW0odGhpcy5vcHRpb25zLnN0ZG91dCk7XG4gICAgdGhpcy5fcmVzdG9yZVN0cmVhbSh0aGlzLm9wdGlvbnMuc3RkZXJyKTtcbiAgfVxuICBfcmVzdG9yZVN0cmVhbShzdHJlYW0pIHtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLl9fd3JpdGUpIHtcbiAgICAgIHN0cmVhbS53cml0ZSA9IHN0cmVhbS5fX3dyaXRlO1xuICAgICAgZGVsZXRlIHN0cmVhbS5fX3dyaXRlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUGF1c2VzIGxvZ2dpbmcsIHF1ZXVlcyBpbmNvbWluZyBsb2dzIHVudGlsIHJlc3VtZWQuXG4gICAqL1xuICBwYXVzZUxvZ3MoKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmVzdW1lcyBsb2dnaW5nLCBwcm9jZXNzaW5nIGFueSBxdWV1ZWQgbG9ncy5cbiAgICovXG4gIHJlc3VtZUxvZ3MoKSB7XG4gICAgcGF1c2VkID0gZmFsc2U7XG4gICAgY29uc3QgX3F1ZXVlID0gcXVldWUuc3BsaWNlKDApO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBfcXVldWUpIHtcbiAgICAgIGl0ZW1bMF0uX2xvZ0ZuKGl0ZW1bMV0sIGl0ZW1bMl0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgbG9nZ2luZyBtZXRob2RzIHdpdGggbW9ja3MgaWYgYSBtb2NrIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NvbnNvbGFPcHRpb25zW1wibW9ja0ZuXCJdfSBtb2NrRm4gLSBUaGUgZnVuY3Rpb24gdG8gdXNlIGZvciBtb2NraW5nIGxvZ2dpbmcgbWV0aG9kcy4gU2VlIHtAbGluayBDb25zb2xhT3B0aW9uc1tcIm1vY2tGblwiXX0uXG4gICAqL1xuICBtb2NrVHlwZXMobW9ja0ZuKSB7XG4gICAgY29uc3QgX21vY2tGbiA9IG1vY2tGbiB8fCB0aGlzLm9wdGlvbnMubW9ja0ZuO1xuICAgIHRoaXMuX21vY2tGbiA9IF9tb2NrRm47XG4gICAgaWYgKHR5cGVvZiBfbW9ja0ZuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIGluIHRoaXMub3B0aW9ucy50eXBlcykge1xuICAgICAgdGhpc1t0eXBlXSA9IF9tb2NrRm4odHlwZSwgdGhpcy5vcHRpb25zLnR5cGVzW3R5cGVdKSB8fCB0aGlzW3R5cGVdO1xuICAgICAgdGhpc1t0eXBlXS5yYXcgPSB0aGlzW3R5cGVdO1xuICAgIH1cbiAgfVxuICBfd3JhcExvZ0ZuKGRlZmF1bHRzLCBpc1Jhdykge1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHBhdXNlZCkge1xuICAgICAgICBxdWV1ZS5wdXNoKFt0aGlzLCBkZWZhdWx0cywgYXJncywgaXNSYXddKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2xvZ0ZuKGRlZmF1bHRzLCBhcmdzLCBpc1Jhdyk7XG4gICAgfTtcbiAgfVxuICBfbG9nRm4oZGVmYXVsdHMsIGFyZ3MsIGlzUmF3KSB7XG4gICAgaWYgKChkZWZhdWx0cy5sZXZlbCB8fCAwKSA+IHRoaXMubGV2ZWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbG9nT2JqID0ge1xuICAgICAgZGF0ZTogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICBhcmdzOiBbXSxcbiAgICAgIC4uLmRlZmF1bHRzLFxuICAgICAgbGV2ZWw6IF9ub3JtYWxpemVMb2dMZXZlbChkZWZhdWx0cy5sZXZlbCwgdGhpcy5vcHRpb25zLnR5cGVzKVxuICAgIH07XG4gICAgaWYgKCFpc1JhdyAmJiBhcmdzLmxlbmd0aCA9PT0gMSAmJiBpc0xvZ09iaihhcmdzWzBdKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihsb2dPYmosIGFyZ3NbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2dPYmouYXJncyA9IFsuLi5hcmdzXTtcbiAgICB9XG4gICAgaWYgKGxvZ09iai5tZXNzYWdlKSB7XG4gICAgICBsb2dPYmouYXJncy51bnNoaWZ0KGxvZ09iai5tZXNzYWdlKTtcbiAgICAgIGRlbGV0ZSBsb2dPYmoubWVzc2FnZTtcbiAgICB9XG4gICAgaWYgKGxvZ09iai5hZGRpdGlvbmFsKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobG9nT2JqLmFkZGl0aW9uYWwpKSB7XG4gICAgICAgIGxvZ09iai5hZGRpdGlvbmFsID0gbG9nT2JqLmFkZGl0aW9uYWwuc3BsaXQoXCJcXG5cIik7XG4gICAgICB9XG4gICAgICBsb2dPYmouYXJncy5wdXNoKFwiXFxuXCIgKyBsb2dPYmouYWRkaXRpb25hbC5qb2luKFwiXFxuXCIpKTtcbiAgICAgIGRlbGV0ZSBsb2dPYmouYWRkaXRpb25hbDtcbiAgICB9XG4gICAgbG9nT2JqLnR5cGUgPSB0eXBlb2YgbG9nT2JqLnR5cGUgPT09IFwic3RyaW5nXCIgPyBsb2dPYmoudHlwZS50b0xvd2VyQ2FzZSgpIDogXCJsb2dcIjtcbiAgICBsb2dPYmoudGFnID0gdHlwZW9mIGxvZ09iai50YWcgPT09IFwic3RyaW5nXCIgPyBsb2dPYmoudGFnIDogXCJcIjtcbiAgICBjb25zdCByZXNvbHZlTG9nID0gKG5ld0xvZyA9IGZhbHNlKSA9PiB7XG4gICAgICBjb25zdCByZXBlYXRlZCA9ICh0aGlzLl9sYXN0TG9nLmNvdW50IHx8IDApIC0gdGhpcy5vcHRpb25zLnRocm90dGxlTWluO1xuICAgICAgaWYgKHRoaXMuX2xhc3RMb2cub2JqZWN0ICYmIHJlcGVhdGVkID4gMCkge1xuICAgICAgICBjb25zdCBhcmdzMiA9IFsuLi50aGlzLl9sYXN0TG9nLm9iamVjdC5hcmdzXTtcbiAgICAgICAgaWYgKHJlcGVhdGVkID4gMSkge1xuICAgICAgICAgIGFyZ3MyLnB1c2goYChyZXBlYXRlZCAke3JlcGVhdGVkfSB0aW1lcylgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2coeyAuLi50aGlzLl9sYXN0TG9nLm9iamVjdCwgYXJnczogYXJnczIgfSk7XG4gICAgICAgIHRoaXMuX2xhc3RMb2cuY291bnQgPSAxO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0xvZykge1xuICAgICAgICB0aGlzLl9sYXN0TG9nLm9iamVjdCA9IGxvZ09iajtcbiAgICAgICAgdGhpcy5fbG9nKGxvZ09iaik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fbGFzdExvZy50aW1lb3V0KTtcbiAgICBjb25zdCBkaWZmVGltZSA9IHRoaXMuX2xhc3RMb2cudGltZSAmJiBsb2dPYmouZGF0ZSA/IGxvZ09iai5kYXRlLmdldFRpbWUoKSAtIHRoaXMuX2xhc3RMb2cudGltZS5nZXRUaW1lKCkgOiAwO1xuICAgIHRoaXMuX2xhc3RMb2cudGltZSA9IGxvZ09iai5kYXRlO1xuICAgIGlmIChkaWZmVGltZSA8IHRoaXMub3B0aW9ucy50aHJvdHRsZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZExvZyA9IEpTT04uc3RyaW5naWZ5KFtcbiAgICAgICAgICBsb2dPYmoudHlwZSxcbiAgICAgICAgICBsb2dPYmoudGFnLFxuICAgICAgICAgIGxvZ09iai5hcmdzXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBpc1NhbWVMb2cgPSB0aGlzLl9sYXN0TG9nLnNlcmlhbGl6ZWQgPT09IHNlcmlhbGl6ZWRMb2c7XG4gICAgICAgIHRoaXMuX2xhc3RMb2cuc2VyaWFsaXplZCA9IHNlcmlhbGl6ZWRMb2c7XG4gICAgICAgIGlmIChpc1NhbWVMb2cpIHtcbiAgICAgICAgICB0aGlzLl9sYXN0TG9nLmNvdW50ID0gKHRoaXMuX2xhc3RMb2cuY291bnQgfHwgMCkgKyAxO1xuICAgICAgICAgIGlmICh0aGlzLl9sYXN0TG9nLmNvdW50ID4gdGhpcy5vcHRpb25zLnRocm90dGxlTWluKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0TG9nLnRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICByZXNvbHZlTG9nLFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGhyb3R0bGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZUxvZyh0cnVlKTtcbiAgfVxuICBfbG9nKGxvZ09iaikge1xuICAgIGZvciAoY29uc3QgcmVwb3J0ZXIgb2YgdGhpcy5vcHRpb25zLnJlcG9ydGVycykge1xuICAgICAgcmVwb3J0ZXIubG9nKGxvZ09iaiwge1xuICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUxvZ0xldmVsKGlucHV0LCB0eXBlcyA9IHt9LCBkZWZhdWx0TGV2ZWwgPSAzKSB7XG4gIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMZXZlbDtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGlmICh0eXBlc1tpbnB1dF0gJiYgdHlwZXNbaW5wdXRdLmxldmVsICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdHlwZXNbaW5wdXRdLmxldmVsO1xuICB9XG4gIHJldHVybiBkZWZhdWx0TGV2ZWw7XG59XG5Db25zb2xhLnByb3RvdHlwZS5hZGQgPSBDb25zb2xhLnByb3RvdHlwZS5hZGRSZXBvcnRlcjtcbkNvbnNvbGEucHJvdG90eXBlLnJlbW92ZSA9IENvbnNvbGEucHJvdG90eXBlLnJlbW92ZVJlcG9ydGVyO1xuQ29uc29sYS5wcm90b3R5cGUuY2xlYXIgPSBDb25zb2xhLnByb3RvdHlwZS5yZW1vdmVSZXBvcnRlcjtcbkNvbnNvbGEucHJvdG90eXBlLndpdGhTY29wZSA9IENvbnNvbGEucHJvdG90eXBlLndpdGhUYWc7XG5Db25zb2xhLnByb3RvdHlwZS5tb2NrID0gQ29uc29sYS5wcm90b3R5cGUubW9ja1R5cGVzO1xuQ29uc29sYS5wcm90b3R5cGUucGF1c2UgPSBDb25zb2xhLnByb3RvdHlwZS5wYXVzZUxvZ3M7XG5Db25zb2xhLnByb3RvdHlwZS5yZXN1bWUgPSBDb25zb2xhLnByb3RvdHlwZS5yZXN1bWVMb2dzO1xuZnVuY3Rpb24gY3JlYXRlQ29uc29sYShvcHRpb25zID0ge30pIHtcbiAgcmV0dXJuIG5ldyBDb25zb2xhKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgeyBDb25zb2xhLCBMb2dMZXZlbHMsIExvZ1R5cGVzLCBjcmVhdGVDb25zb2xhIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/consola@3.4.2/node_modules/consola/dist/core.mjs\n");

/***/ })

};
;